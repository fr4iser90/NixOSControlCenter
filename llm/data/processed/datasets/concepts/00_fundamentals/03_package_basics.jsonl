{"concept": "What is a Nix package?", "explanation": "[Package Management] A Nix package is a self-contained unit that includes the software and all its dependencies. Each package is built by a pure function and stored in /nix/store with a unique hash-based path. This ensures reproducibility and prevents conflicts between different versions.", "examples": ["Firefox package with all dependencies", "Python with specific library versions"], "references": ["Nix Package Guide", "Package Management Basics"]}

{"concept": "How do you install packages in NixOS?", "explanation": "[Package Management] There are two main ways to install packages in NixOS: 1) System-wide through configuration.nix using environment.systemPackages, requiring nixos-rebuild switch, or 2) Per-user using nix-env -i package-name. System packages are available to all users, while user packages are specific to individual profiles.", "examples": ["Adding packages to configuration.nix", "Using nix-env for user packages"], "references": ["Package Installation Guide", "User Environment Management"]}

{"concept": "What is the difference between channels and flakes?", "explanation": "[Package Management] Channels are the traditional way of getting packages in NixOS, providing rolling repositories of package definitions. Flakes are the modern replacement, offering reproducible package sources with explicit versions and dependencies. Flakes are preferred for new projects due to better reproducibility.", "examples": ["Using nixos-unstable channel", "Creating a flake.nix"], "references": ["Channel Documentation", "Flakes Guide"]}

{"concept": "How does NixOS handle package dependencies?", "explanation": "[Package Management] NixOS handles dependencies by storing each package with its exact dependencies in /nix/store. Dependencies are specified in the package definition and are part of the package's hash. This allows multiple versions of the same package to coexist without conflicts.", "examples": ["Different Python versions with different packages", "Multiple library versions"], "references": ["Dependency Management Guide", "Package Isolation Documentation"]}

{"concept": "What is garbage collection in NixOS?", "explanation": "[Package Management] Garbage collection removes unused packages from /nix/store. A package is considered unused if it's not referenced by any active profile or running process. This keeps the system clean while ensuring that needed packages remain available.", "examples": ["Running nix-collect-garbage", "Deleting old generations"], "references": ["Garbage Collection Guide", "Storage Management"]}

{"concept": "How do you search for packages in NixOS?", "explanation": "[Package Management] Packages can be searched using several tools: 1) nix search package-name for command line, 2) https://search.nixos.org for web interface, 3) configuration options search in NixOS manual. Search results show package names, descriptions, and available versions.", "examples": ["nix search firefox", "Finding packages on search.nixos.org"], "references": ["Package Search Guide", "NixOS Package Repository"]}

{"concept": "What are package overlays?", "explanation": "[Package Management] Overlays are a way to customize or extend the package set without modifying Nixpkgs directly. They're functions that take the original package set and return a modified one. This allows for package customization while maintaining reproducibility.", "examples": ["Creating custom package versions", "Overriding package attributes"], "references": ["Overlay Documentation", "Package Customization Guide"]}

{"concept": "How does version management work in NixOS?", "explanation": "[Package Management] NixOS can have multiple versions of the same package installed simultaneously due to its store architecture. Version selection happens through profiles and package specifications. This enables safe testing of new versions and prevents dependency conflicts.", "examples": ["Installing specific package versions", "Managing multiple Python versions"], "references": ["Version Management Guide", "Package Versioning Documentation"]}

{"concept": "What is a package derivation?", "explanation": "[Package Management] A derivation is a description of how to build a package. It specifies source code, dependencies, build instructions, and other attributes. When built, it produces a unique result in /nix/store. All NixOS packages are built from derivations.", "examples": ["Simple package derivation", "Complex build process"], "references": ["Derivation Guide", "Package Building Documentation"]}

{"concept": "How do you create custom packages in NixOS?", "explanation": "[Package Management] Custom packages are created by writing derivations in the Nix language. The process involves: 1) Specifying source and dependencies, 2) Defining build steps, 3) Setting meta information. Custom packages can be added to your configuration or shared through overlays.", "examples": ["Basic package creation", "Packaging a Python application"], "references": ["Package Creation Guide", "Custom Package Documentation"]}
