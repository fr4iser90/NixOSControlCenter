# Module Migrations - Core Modules

## Übersicht

**Core-Module** (wie Features) können Migrations-Pläne haben, um Breaking Changes zwischen Versionen zu handhaben.

## Migrations-Struktur

### Verzeichnisstruktur

```
core/
├── desktop/
│   ├── migrations/
│   │   ├── v1.0-to-v1.1.nix    # Minor version migration
│   │   ├── v1.0-to-v2.0.nix    # Major version migration
│   │   └── v1.1-to-v2.0.nix    # Chain migration
│   ├── options.nix
│   └── ...
├── hardware/
│   ├── migrations/
│   │   └── v1.0-to-v2.0.nix
│   └── ...
└── ...
```

### Migration-Plan Struktur

```nix
# migrations/v1.0-to-v2.0.nix
{ lib, ... }:

{
  # Source and target versions
  fromVersion = "1.0";
  toVersion = "2.0";
  
  # Option renamings (old path → new path)
  optionRenamings = {
    "systemConfig.desktop.enable" = "systemConfig.desktop.enabled";
    "systemConfig.desktop.theme.dark" = "systemConfig.desktop.theme.mode";
  };
  
  # Migration script (Bash, executed during migration)
  migrationScript = ''
    # Custom migration logic
    # Example: Convert boolean to enum
    if [ "$OLD_VALUE" = "true" ]; then
      echo "dark"
    else
      echo "light"
    fi
  '';
  
  # Structure changes (nested → flat or vice versa)
  structureMappings = {
    "systemConfig.desktop.display.manager" = "systemConfig.desktop.displayManager";
  };
}
```

## Auto-Discovery

Migrations-Pläne werden automatisch von `module-version-check.nix` entdeckt:

1. **Scannt** `core/*/migrations/vX-to-vY.nix` Dateien
2. **Erstellt** Migrations-Chains automatisch
3. **Führt** Migrationen aus, wenn Versionen unterschiedlich sind

## Stufe 0 → 1 Migration (Sonderfall)

**Stufe 0 → 1 Migration** ist ein **einmaliger Übergang** von monolithisch zu modular:

- **Wann**: Modul hat keine `options.nix` (Stufe 0) → bekommt `options.nix` (Stufe 1)
- **Was passiert**: 
  - Liest Config aus `system-config.nix` (monolithisch)
  - Erstellt `user-configs/*-config.nix` (modular)
  - Kopiert Modul-Code inkl. `options.nix`
- **Wo**: Hardcoded in `system-update.nix` (`migrate_stage0_to_stage1`)
- **Warum kein Plan**: Einmaliger Übergang, nicht wiederholbar

**Optional**: Könnte auch einen Plan haben in `migrations/v0-to-v1.nix`, aber aktuell hardcoded.

## Normale Module-Migrationen (v1.0 → v2.0)

**Normale Migrationen** haben Pläne in `migrations/vX-to-vY.nix`:

- **Wann**: Version ändert sich (z.B. 1.0 → 2.0)
- **Was passiert**: 
  - Lädt Migrations-Plan
  - Wendet `optionRenamings` an
  - Führt `migrationScript` aus
  - Aktualisiert Version in `user-configs/*-config.nix`
- **Wo**: `core/*/migrations/vX-to-vY.nix`
- **Auto-Discovery**: Wird von `module-version-check.nix` gefunden

## Unterschied zu System-Config Migration

| Typ | Wo | Was | Beispiel |
|-----|-----|-----|----------|
| **System-Config Migration** | `core/config/config-schema/migrations/` | Migriert `system-config.nix` Struktur | v1.0 → v2.0 (monolithisch → modular) |
| **Module Migration** | `core/*/migrations/` | Migriert Modul-Optionen | desktop v1.0 → v2.0 (Optionen ändern) |
| **Stufe 0 → 1** | Hardcoded in `system-update.nix` | Einmaliger Übergang | Modul ohne Version → mit Version |

## Beispiel: Desktop-Modul Migration

### v1.0 → v2.0 Migration

**Vorher (v1.0)**:
```nix
{
  desktop = {
    enable = true;
    theme = {
      dark = true;
    };
  };
}
```

**Nachher (v2.0)**:
```nix
{
  desktop = {
    enabled = true;  # Renamed: enable → enabled
    theme = {
      mode = "dark";  # Changed: dark (bool) → mode (enum)
    };
  };
}
```

**Migrations-Plan** (`migrations/v1.0-to-v2.0.nix`):
```nix
{ lib, ... }:

{
  fromVersion = "1.0";
  toVersion = "2.0";
  
  optionRenamings = {
    "systemConfig.desktop.enable" = "systemConfig.desktop.enabled";
  };
  
  migrationScript = ''
    # Convert theme.dark (bool) → theme.mode (enum)
    if grep -q 'dark = true' "$CONFIG_FILE"; then
      sed -i 's/dark = true/mode = "dark"/' "$CONFIG_FILE"
    elif grep -q 'dark = false' "$CONFIG_FILE"; then
      sed -i 's/dark = false/mode = "light"/' "$CONFIG_FILE"
    fi
  '';
}
```

## Integration in system-update

`system-update` prüft automatisch:

1. **Versionen vergleichen**: SOURCE vs. TARGET
2. **Migrations-Plan finden**: Auto-Discovery in `migrations/`
3. **Migration ausführen**: Wenn Plan existiert
4. **User-Configs schützen**: NIEMALS überschreiben

## Wann Migration-Plan erstellen?

**Erstelle Migrations-Plan wenn**:
- ✅ Option-Namen ändern
- ✅ Option-Typen ändern (bool → enum)
- ✅ Option-Struktur ändert (flat → nested)
- ✅ Breaking Changes

**Kein Plan nötig wenn**:
- ❌ Nur neue Optionen hinzugefügt (Minor-Version)
- ❌ Bugfixes (Patch-Version)
- ❌ Code-Refactoring ohne Config-Änderungen

## Zusammenfassung

1. **Core-Module** haben `migrations/` Verzeichnisse (wie Features)
2. **Pläne** in `core/*/migrations/vX-to-vY.nix`
3. **Auto-Discovery** durch `module-version-check.nix`
4. **Stufe 0 → 1** ist Sonderfall (hardcoded, einmalig)
5. **Normale Migrationen** haben Pläne (v1.0 → v2.0, etc.)

