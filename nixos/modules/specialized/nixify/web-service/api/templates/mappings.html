{{define "mappings"}}
<div class="container">
    <header>
        <h1>{{.T "mappings.title"}}</h1>
        <p class="subtitle">{{.T "mappings.subtitle"}}</p>
    </header>

    <div class="section">
        <div class="search-container">
            <input type="text" id="searchInput" placeholder="{{.T "mappings.search"}}" class="search-input-full">
        </div>
        
        <div id="topMigrationApps" class="top-migration-section">
            <h2 class="top-migration-title">
                ‚≠ê {{.T "mappings.top_migration_apps"}}
            </h2>
            <p class="top-migration-subtitle">{{.T "mappings.top_migration_subtitle"}}</p>
            <div id="topAppsList">
                <!-- Top Migration Apps will be loaded here -->
            </div>
        </div>
        
        <div id="allProgramsSection" style="margin-top: var(--spacing-xl);">
            <h2 id="allProgramsTitle" style="font-size: 1.3em; margin-bottom: var(--spacing-md); color: var(--color-text-primary);">
                {{.T "mappings.all_programs"}}
            </h2>
            <div id="programsList">
                <!-- All programs will be loaded here via JavaScript -->
            </div>
        </div>
        
        <div id="noResults" class="no-results">
            {{.T "mappings.no_results"}}
        </div>
    </div>
</div>

<script nonce="{{.Nonce}}">
    const programs = {{.ProgramsJSON}};
    const mappingTranslations = {{.MappingTranslationsJSON}} || {};
    const translations = {
        supported: "{{.T "mappings.status.supported"}}",
        alternative: "{{.T "mappings.status.alternative"}}",
        wine: "{{.T "mappings.status.wine"}}",
        proton: "{{.T "mappings.status.proton"}}",
        flatpak: "{{.T "mappings.status.flatpak"}}",
        appimage: "{{.T "mappings.status.appimage"}}",
        module_only: "{{.T "mappings.status.module_only"}}",
        category: "{{.T "mappings.category"}}",
        alternatives: "{{.T "mappings.alternatives"}}",
        total: "{{.T "mappings.total"}}"
    };
    
    // Translation function for mapping database texts
    function translate(key) {
        if (!key) return '';
        // Remove "mappings.programs." prefix if present
        let lookupKey = key;
        if (key.startsWith('mappings.programs.')) {
            lookupKey = key.substring('mappings.programs.'.length);
        }
        // Navigate through key path (e.g., "discord.alternatives.vesktop.reason")
        const parts = lookupKey.split('.');
        let current = mappingTranslations;
        for (const part of parts) {
            if (current && typeof current === 'object' && part in current) {
                current = current[part];
            } else {
                return key; // Return key if translation not found
            }
        }
        return (typeof current === 'string' ? current : key);
    }
    
    function renderPrograms(filteredPrograms, targetContainerId) {
        const container = document.getElementById(targetContainerId || 'programsList');
        const noResults = document.getElementById('noResults');
        
        if (!container) {
            console.error('Container not found:', targetContainerId || 'programsList');
            return '';
        }
        
        if (filteredPrograms.length === 0) {
            container.innerHTML = '';
            if (targetContainerId !== 'topAppsList') {
                noResults.style.display = 'block';
            }
            return '';
        }
        
        if (targetContainerId !== 'topAppsList') {
            noResults.style.display = 'none';
        }
        const html = filteredPrograms.map(prog => {
            const name = prog.name || 'Unknown';
            const category = prog.category || 'uncategorized';
            const hasPackage = prog.nixos_package != null;
            const hasModule = prog.module != null;
            const hasWine = prog.wine === true;
            const hasProton = prog.proton === true;
            const hasFlatpak = prog.flatpak != null;
            const hasAppImage = prog.appimage === true;
            const isAlternative = prog.nixos_package != null && prog.note_key && translate(prog.note_key).toLowerCase().includes('alternative');
            
            let status = 'alternative';
            let statusClass = 'status-alternative';
            let statusText = translations.alternative;
            let statusIcon = 'üîÅ';
            
            // Native = hat Package (egal ob Modul oder nicht)
            if (hasPackage) {
                if (isAlternative) {
                    status = 'alternative';
                    statusClass = 'status-alternative';
                    statusText = translations.alternative;
                    statusIcon = 'üîÅ';
                } else {
                    status = 'supported';
                    statusClass = 'status-supported';
                    statusText = translations.supported;
                    statusIcon = 'üü¢';
                }
            }
            // Via Wine
            else if (hasWine) {
                status = 'wine';
                statusClass = 'status-wine';
                statusText = translations.wine;
                statusIcon = 'üç∑';
            }
            // Via Proton
            else if (hasProton) {
                status = 'proton';
                statusClass = 'status-proton';
                statusText = translations.proton;
                statusIcon = 'üéÆ';
            }
            // Via Flatpak
            else if (hasFlatpak) {
                status = 'flatpak';
                statusClass = 'status-flatpak';
                statusText = translations.flatpak;
                statusIcon = 'üì¶';
            }
            // Via AppImage
            else if (hasAppImage) {
                status = 'appimage';
                statusClass = 'status-appimage';
                statusText = translations.appimage;
                statusIcon = 'üì¶';
            }
            // Nur Modul (kein Package)
            else if (hasModule) {
                status = 'module_only';
                statusClass = 'status-module';
                statusText = translations.module_only;
                statusIcon = 'üß©';
            }
            // Hat Alternativen (Fallback)
            else if (prog.alternatives && prog.alternatives.length > 0) {
                status = 'alternative';
                statusClass = 'status-alternative';
                statusText = translations.alternative;
                statusIcon = 'üîÅ';
            }
            
            const isTopApp = prog.priority === 'top';
            const priorityClass = isTopApp ? 'program-card-top' : (prog.priority === 'high' ? 'program-card-high' : '');
            
            return `
                <div class="program-card ${priorityClass}">
                    <div class="program-info">
                        <div class="program-name">
                            ${isTopApp ? '<span class="top-badge">‚≠ê</span> ' : ''}${escapeHtml(name)}
                        </div>
                        ${isTopApp && prog.short_description_key ? `<div class="program-short-description">${escapeHtml(translate(prog.short_description_key))}</div>` : ''}
                        <div class="program-category">${translations.category}: ${escapeHtml(category)}</div>
                        ${prog.nixos_package ? `<div class="program-meta">Package: <code>${escapeHtml(prog.nixos_package)}</code></div>` : ''}
                        ${prog.module ? `<div class="program-meta">Module: <code>${escapeHtml(prog.module)}</code></div>` : ''}
                        ${prog.flatpak && !hasPackage ? `<div class="program-meta">Flatpak: <code>${escapeHtml(prog.flatpak)}</code></div>` : ''}
                        ${prog.note_key ? `<div class="program-note">${escapeHtml(translate(prog.note_key))}</div>` : ''}
                        ${prog.alternatives && prog.alternatives.length > 0 ? `
                            <div class="program-alternatives">
                                <strong>${translations.alternatives || 'Alternatives'}:</strong>
                                ${prog.alternatives.map(alt => `
                                    <div class="alternative-item">
                                        <span class="alternative-name">${escapeHtml(alt.name)}</span>
                                        ${alt.package ? `<code class="alternative-package">${escapeHtml(alt.package)}</code>` : ''}
                                        ${alt.reason_key ? `<span class="alternative-reason">${escapeHtml(translate(alt.reason_key))}</span>` : ''}
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                    </div>
                    <div class="program-status ${statusClass}">${statusIcon} ${statusText}</div>
                </div>
            `;
        }).join('');
        
        container.innerHTML = html;
        return html;
    }
    
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // Feste Reihenfolge f√ºr Top Migration Apps (strategisch optimiert)
    const topAppsOrder = [
        'Microsoft Office',
        'Google Chrome',
        'Visual Studio Code',
        'Steam',
        'Adobe Photoshop'
    ];
    
    // Sortiere Programme nach Priorit√§t
    function sortPrograms(progs) {
        const priorityOrder = { 'top': 0, 'high': 1, 'normal': 2 };
        return [...progs].sort((a, b) => {
            const aPriority = priorityOrder[a.priority || 'normal'] || 2;
            const bPriority = priorityOrder[b.priority || 'normal'] || 2;
            if (aPriority !== bPriority) {
                return aPriority - bPriority;
            }
            // Bei Top Apps: feste Reihenfolge
            if (aPriority === 0 && bPriority === 0) {
                const aIndex = topAppsOrder.indexOf(a.name);
                const bIndex = topAppsOrder.indexOf(b.name);
                if (aIndex !== -1 && bIndex !== -1) {
                    return aIndex - bIndex;
                }
            }
            // Bei gleicher Priorit√§t alphabetisch sortieren
            return (a.name || '').localeCompare(b.name || '');
        });
    }
    
    // Render Top Migration Apps separat
    function renderTopApps() {
        if (!Array.isArray(programs)) {
            console.error('Programs is not an array:', typeof programs);
            return;
        }
        const topApps = programs.filter(prog => {
            const priority = prog.priority || prog.Priority || null;
            return priority === 'top' || priority === 'Top';
        });
        if (topApps.length > 0) {
            // Top Apps in strategischer Reihenfolge sortieren
            const sortedTopApps = sortPrograms(topApps);
            renderPrograms(sortedTopApps, 'topAppsList');
        } else {
            const topSection = document.getElementById('topMigrationApps');
            if (topSection) {
                topSection.style.display = 'none';
            }
        }
    }
    
    // Function to render all programs (excluding top apps) - f√ºr Suche
    function renderAllPrograms() {
        if (!Array.isArray(programs) || programs.length === 0) {
            return;
        }
        
        const allPrograms = programs.filter(prog => {
            return prog.priority !== 'top';
        });
        
        if (allPrograms.length > 0) {
            renderPrograms(sortPrograms(allPrograms), 'programsList');
        }
    }
    
    // Search handler
    document.getElementById('searchInput').addEventListener('input', (e) => {
        const query = e.target.value.toLowerCase();
        const filtered = programs.filter(prog => {
            const name = (prog.name || '').toLowerCase();
            const category = (prog.category || '').toLowerCase();
            const package = (prog.nixos_package || '').toLowerCase();
            return name.includes(query) || category.includes(query) || package.includes(query);
        });
        
        // Bei Suche: Top Apps ausblenden, alle Programme zeigen
        if (query) {
            document.getElementById('topMigrationApps').style.display = 'none';
            document.getElementById('allProgramsTitle').textContent = '{{.T "mappings.search_results"}}';
            renderPrograms(sortPrograms(filtered), 'programsList');
        } else {
            // Leere Suche = zur√ºck zu normaler Ansicht
            document.getElementById('topMigrationApps').style.display = 'block';
            document.getElementById('allProgramsTitle').textContent = '{{.T "mappings.all_programs"}}';
            renderAllPrograms();
        }
    });
    
    // Initial render - BEIDE GLEICH BEHANDELN
    if (!Array.isArray(programs)) {
        console.error('Programs is not an array!', typeof programs);
    } else if (programs.length === 0) {
        console.warn('No programs loaded!');
    } else {
        // 1. Top Apps rendern - DIREKT
        const topApps = programs.filter(prog => {
            const priority = prog.priority || prog.Priority || null;
            return priority === 'top' || priority === 'Top';
        });
        if (topApps.length > 0) {
            renderPrograms(sortPrograms(topApps), 'topAppsList');
        }
        
        // 2. Alle anderen Programme rendern - GLEICHE LOGIK
        const allPrograms = programs.filter(prog => {
            const priority = prog.priority;
            return priority !== 'top';
        });
        if (allPrograms.length > 0) {
            renderPrograms(sortPrograms(allPrograms), 'programsList');
        }
        
        // Show stats
        const statsContainer = document.getElementById('programsList')?.parentNode;
        if (statsContainer) {
            const existingStats = statsContainer.querySelector('.stats');
            if (existingStats) {
                existingStats.remove();
            }
            const stats = document.createElement('div');
            stats.className = 'stats';
            stats.textContent = `${translations.total}: ${programs.length}`;
            statsContainer.appendChild(stats);
        }
    }
</script>
{{end}}
